package io.quantum.trading.brokers.forex.mt5protocol.mtapi.mt5;

 class Crypt
{
	public static byte[] CryptKey = new byte[] {0x41, (byte)0xB6, 0x7F, 0x58, 0x38, 0x0C, (byte)0xF0, 0x2D, 0x7B, 0x39, 0x08, (byte)0xFE, 0x21, (byte)0xBB, 0x41, 0x58};

	public static byte[] EasyCrypt(byte[] buf)
	{
		int Last = 0;
		for (int i = 0; i < buf.length; i++)
		{
			buf[i]  ^= (byte)((Last + (CryptKey[i & 0xF] & 0xFF)) & 0xFF);
			Last = (buf[i] & 0xFF);
		}
		return buf;
	}

	public static byte[] EasyDecrypt(byte[] buf)
	{
		int Last = 0;
		for (int i = 0; i < buf.length; i++)
		{
			int lst = Last;
			Last = (buf[i] & 0xFF);
//C# TO JAVA CONVERTER WARNING: Unsigned integer types have no direct equivalent in Java:
//ORIGINAL LINE: buf[i] ^= (byte)(lst + CryptKey[i & 0xF]);
			buf[i] ^= (byte)((lst + (CryptKey[i & 0xF] & 0xFF)) & 0xFF);
		}
	   return buf;
	}

//C# TO JAVA CONVERTER WARNING: Unsigned integer types have no direct equivalent in Java:
//ORIGINAL LINE: public static byte[] Encrypt(byte[] buf)
	public static byte[] Encrypt(byte[] buf)
	{
		int Last = 0;
//C# TO JAVA CONVERTER WARNING: Unsigned integer types have no direct equivalent in Java:
//ORIGINAL LINE: byte[] res = new byte[buf.Length];
		byte[] res = new byte[buf.length];
		for (int i = 0; i < buf.length; i++)
		{
//C# TO JAVA CONVERTER WARNING: Unsigned integer types have no direct equivalent in Java:
//ORIGINAL LINE: res[i] = (byte)(buf[i] ^ (Last + CryptKey[i & 0xF]));
			res[i] = (byte)(((buf[i] & 0xFF) ^ (Last + (CryptKey[i & 0xF] & 0xFF))) & 0xFF);
			Last = (res[i] & 0xFF);
		}
		return buf;
	}

//C# TO JAVA CONVERTER WARNING: Unsigned integer types have no direct equivalent in Java:
//ORIGINAL LINE: public static byte[] Decrypt(byte[] buf)
	public static byte[] Decrypt(byte[] buf)
	{
		int Last = 0;
//C# TO JAVA CONVERTER WARNING: Unsigned integer types have no direct equivalent in Java:
//ORIGINAL LINE: byte[] res = new byte[buf.Length];
		byte[] res = new byte[buf.length];
		for (int i = 0; i < buf.length; i++)
		{
//C# TO JAVA CONVERTER WARNING: Unsigned integer types have no direct equivalent in Java:
//ORIGINAL LINE: res[i] = (byte)(buf[i] ^ (Last + CryptKey[i & 0xF]));
			res[i] = (byte)(((buf[i] & 0xFF) ^ (Last + (CryptKey[i & 0xF] & 0xFF))) & 0xFF);
			Last = (buf[i] & 0xFF);
		}
		return res;
	}

//C# TO JAVA CONVERTER WARNING: Unsigned integer types have no direct equivalent in Java:
//ORIGINAL LINE: public static byte[] Encode(byte[] buf, byte[] key)
//	public static byte[] Encode(byte[] buf, byte[] key)
//	{
////C# TO JAVA CONVERTER WARNING: Unsigned integer types have no direct equivalent in Java:
////ORIGINAL LINE: key = new byte[] { 0x43, 0xb0, 0xbe, 0xc7, 0xce, 0x46, 0x75, 0x9d, 0x88, 0xee, 0xb1, 0x04, 0x00, 0x2e, 0xd6, 0x57, 0x98, 0x75, 0xf5, 0xca, 0x23, 0xb5, 0x56, 0xb0, 0x83, 0xd6, 0xef, 0xcc, 0x20, 0xfb, 0x1f, 0xc0, 0x63, 0xe2, 0xc8, 0xeb, 0x0a, 0x90, 0xc2, 0xe4, 0x6b, 0x1a, 0x8d, 0xf5, 0x3c, 0xc6, 0x68, 0x88, 0x8e, 0xec, 0x20, 0x4a, 0x89, 0x14, 0xd1, 0x1f, 0x29, 0x41, 0xf6, 0x86, 0x32, 0x59, 0xda, 0xcc, 0xa4, 0x87, 0x1f, 0xa2, 0xff, 0xc6, 0xf6, 0xa5, 0x9f, 0x50, 0x6b, 0xa6, 0xf8, 0xbb, 0x46, 0x3d, 0xa0, 0x1d, 0xc1, 0x47, 0xc5, 0x4f, 0xe0, 0x35, 0xe6, 0xdd, 0x43, 0x80, 0xc9, 0xe8, 0xc8, 0x0e, 0x7f, 0xde, 0xd0, 0x33, 0x33, 0x8d, 0x0b, 0x0b, 0xcc, 0x7d, 0x74, 0xf5, 0x7b, 0x12, 0xbd, 0x16, 0x93, 0xf1, 0x01, 0xca, 0x8b, 0x38, 0xa0, 0xfc, 0x0e, 0x1d, 0x24, 0xac, 0x4d, 0xc3, 0xbe, 0x6a, 0xe7, 0xa6, 0xc6, 0x1b, 0x1b, 0xd9, 0x3e, 0x98, 0x57, 0x0f, 0xdf, 0x12, 0x6f, 0x49, 0x47, 0x6b, 0xb6, 0x0c, 0x00, 0x76, 0xd3, 0x70, 0xa6, 0x0d, 0x0f, 0x41, 0xc7, 0x55, 0x98, 0x12, 0xfa, 0x86, 0x75, 0x0e, 0xbc, 0x44, 0xe8, 0x24, 0xcf, 0x0f, 0x18, 0xf9, 0xb4, 0x18, 0xae, 0x0e, 0x57, 0x0b, 0x16, 0xc9, 0xa2, 0x6a, 0xd7, 0xb4, 0x81, 0x7f, 0x40, 0xef, 0x87, 0xd8, 0xcb, 0xc7, 0x53, 0x6c, 0xd9, 0xe5, 0x03, 0x72, 0x2d, 0xdb, 0xb4, 0x25, 0x61, 0xce, 0x43, 0xbb, 0x2a, 0x72, 0x27, 0xaf, 0x06, 0x71, 0x63, 0xa2, 0x74, 0xea, 0x00, 0x1d, 0xa7, 0xd7, 0x1d, 0x42, 0x3d, 0x6e, 0xcf, 0x49, 0x5f, 0x2b, 0x32, 0x2f, 0x31, 0xd7, 0x8d, 0xc6, 0x20, 0x70, 0x98, 0xb6, 0x8c, 0xc7, 0x6f, 0x72, 0x57, 0xd2, 0x35, 0x75, 0x5d, 0x43, 0x76, 0x05, 0x17, 0x78, 0xd7, 0xa1, 0xc4, 0x2d, 0x36, 0x28 };
//		key = new byte[] {0x43, (byte)0xb0, (byte)0xbe, (byte)0xc7, (byte)0xce, 0x46, 0x75, (byte)0x9d, (byte)0x88, (byte)0xee, (byte)0xb1, 0x04, 0x00, 0x2e, (byte)0xd6,
//				0x57, (byte)0x98, 0x75, (byte)0xf5, (byte)0xca, 0x23, (byte)0xb5, 0x56, (byte)0xb0, (byte)0x83, (byte)0xd6, (byte)0xef, (byte)0xcc, 0x20, (byte)0xfb,
//				0x1f, (byte)0xc0, 0x63, (byte)0xe2, (byte)0xc8, (byte)0xeb, 0x0a, (byte)0x90, (byte)0xc2, (byte)0xe4, 0x6b, 0x1a, (byte)0x8d, (byte)0xf5, 0x3c, (byte)0xc6,
//				0x68, (byte)0x88, (byte)0x8e, (byte)0xec, 0x20, 0x4a, (byte)0x89, 0x14,(byte) 0xd1, 0x1f, 0x29, 0x41, (byte)0xf6, (byte)0x86, 0x32, 0x59, (byte)0xda,
//				(byte)0xcc, (byte)0xa4, (byte)0x87, 0x1f, (byte)0xa2, (byte)0xff, (byte)0xc6, (byte)0xf6, (byte)0xa5, (byte)0x9f, 0x50, 0x6b, (byte)0xa6, (byte)0xf8,
//				(byte)0xbb, 0x46, 0x3d, (byte)0xa0, 0x1d, (byte)0xc1, 0x47,(byte) 0xc5, 0x4f,(byte) 0xe0, 0x35,(byte) 0xe6, (byte)0xdd, 0x43, (byte)0x80, (byte)0xc9,
//				(byte)0xe8, (byte)0xc8, 0x0e, 0x7f, (byte)0xde,(byte) 0xd0, 0x33, 0x33, (byte)0x8d, 0x0b, 0x0b, (byte)0xcc, 0x7d, 0x74, (byte)0xf5, 0x7b, 0x12, (byte)0xbd,
//				(byte)0x16, (byte)0x93, (byte)0xf1, 0x01, (byte)0xca, (byte)0x8b, 0x38, 0(byte)xa0, 0xfc, 0x0e, 0x1d, 0x24, 0xac, 0x4d, 0xc3, 0xbe, 0x6a, 0xe7, 0xa6, 0xc6, 0x1b, 0x1b, 0xd9, 0x3e, 0x98, 0x57, 0x0f, 0xdf, 0x12, 0x6f, 0x49, 0x47, 0x6b, 0xb6, 0x0c, 0x00, 0x76, 0xd3, 0x70, 0xa6, 0x0d, 0x0f, 0x41, 0xc7, 0x55, 0x98, 0x12, 0xfa, 0x86, 0x75, 0x0e, 0xbc, 0x44, 0xe8, 0x24, 0xcf, 0x0f, 0x18, 0xf9, 0xb4, 0x18, 0xae, 0x0e, 0x57, 0x0b, 0x16, 0xc9, 0xa2, 0x6a, 0xd7, 0xb4, 0x81, 0x7f, 0x40, 0xef, 0x87, 0xd8, 0xcb, 0xc7, 0x53, 0x6c, 0xd9, 0xe5, 0x03, 0x72, 0x2d, 0xdb, 0xb4, 0x25, 0x61, 0xce, 0x43, 0xbb, 0x2a, 0x72, 0x27, 0xaf, 0x06, 0x71, 0x63, 0xa2, 0x74, 0xea, 0x00, 0x1d, 0xa7, 0xd7, 0x1d, 0x42, 0x3d, 0x6e, 0xcf, 0x49, 0x5f, 0x2b, 0x32, 0x2f, 0x31, 0xd7, 0x8d, 0xc6, 0x20, 0x70, 0x98, 0xb6, 0x8c, 0xc7, 0x6f, 0x72, 0x57, 0xd2, 0x35, 0x75, 0x5d, 0x43, 0x76, 0x05, 0x17, 0x78, 0xd7, 0xa1, 0xc4, 0x2d, 0x36, 0x28};
//		int Last = 0;
////C# TO JAVA CONVERTER WARNING: Unsigned integer types have no direct equivalent in Java:
////ORIGINAL LINE: byte[] res = new byte[buf.Length];
//		byte[] res = new byte[buf.length];
//		for (int i = 0; i < buf.length; i++)
//		{
////C# TO JAVA CONVERTER WARNING: Unsigned integer types have no direct equivalent in Java:
////ORIGINAL LINE: res[i] = (byte)(buf[i] ^ (Last + key[i % key.Length]));
//			res[i] = (byte)(((buf[i] & 0xFF) ^ (Last + (key[i % key.length] & 0xFF))) & 0xFF);
//			Last = (res[i] & 0xFF);
//		}
//		return res;
//	}

//C# TO JAVA CONVERTER WARNING: Unsigned integer types have no direct equivalent in Java:
//ORIGINAL LINE: public static byte[] Decode(byte[] buf, byte[] key)
	public static byte[] Decode(byte[] buf, byte[] key)
	{
		//var decoded = new byte[]
		int Last = 0;
//C# TO JAVA CONVERTER WARNING: Unsigned integer types have no direct equivalent in Java:
//ORIGINAL LINE: byte[] res = new byte[buf.Length];
		byte[] res = new byte[buf.length];
		for (int i = 0; i < buf.length; i++)
		{
//C# TO JAVA CONVERTER WARNING: Unsigned integer types have no direct equivalent in Java:
//ORIGINAL LINE: res[i] = (byte)(buf[i] ^ (Last + key[i % key.Length]));
			res[i] = (byte)(((buf[i] & 0xFF) ^ (Last + (key[i % key.length] & 0xFF))) & 0xFF);
			Last = (buf[i] & 0xFF);
		}
		return res;
	}

//C# TO JAVA CONVERTER WARNING: Unsigned integer types have no direct equivalent in Java:
//ORIGINAL LINE: static byte[] _HardId = new byte[16];
	private static byte[] _HardId = new byte[16];

	private static void CreateHardId()
	{
//C# TO JAVA CONVERTER WARNING: Unsigned integer types have no direct equivalent in Java:
//ORIGINAL LINE: uint seed = (uint)DateTime.Now.Ticks;
		int seed = (int)(java.time.LocalDateTime.now().getNano() & 0xFFFFFFFFL); //522441350;//
//C# TO JAVA CONVERTER WARNING: Unsigned integer types have no direct equivalent in Java:
//ORIGINAL LINE: byte[] data = new byte[256];
		byte[] data = new byte[256];
		for (int i = 0; i < 256; i++)
		{
			seed = seed * 214013 + 2531011;
//C# TO JAVA CONVERTER WARNING: The right shift operator was not replaced by Java's logical right shift operator since the left operand was not confirmed to be of an unsigned type, but you should review whether the logical right shift operator (>>>) is more appropriate:
//C# TO JAVA CONVERTER WARNING: Unsigned integer types have no direct equivalent in Java:
//ORIGINAL LINE: data[i] = (byte)((seed >> 16) & 0xFF);
			data[i] = (byte)(((seed & 0xFFFFFFFFL) >> 16) & 0xFF);
		}
		//MD5 md = new MD5();
		_HardId = MD5.computeMD5(data);
		_HardId[0] = 0;
		for (int i = 1; i < 16; i++)
		{
			_HardId[0] += (_HardId[i] & 0xFF);
		}
	}

//C# TO JAVA CONVERTER WARNING: Unsigned integer types have no direct equivalent in Java:
//ORIGINAL LINE: public static byte[] GetHardId()
	public static byte[] GetHardId()
	{
		synchronized (_HardId)
		{
		if ((_HardId[0] & 0xFF) == 0 || (_HardId[15] & 0xFF) == 0)
		{
			CreateHardId();
		}
		}
		return _HardId;
	}
}